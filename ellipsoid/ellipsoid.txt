ellipsoid.py


QuakeML ellipsoid parameters:

    :param semi_major_axis_length: Largest uncertainty, corresponding to the
        semi-major axis of the confidence ellipsoid. Unit: m
    :param semi_minor_axis_length: Smallest uncertainty, corresponding to the
        semi-minor axis of the confidence ellipsoid. Unit: m
    :param semi_intermediate_axis_length: Uncertainty in direction orthogonal
        to major and minor axes of the confidence ellipsoid. Unit: m
    :param major_axis_plunge: Plunge angle of major axis of confidence
        ellipsoid. Corresponds to Tait-Bryan angle φ. Unit: deg
    :param major_axis_azimuth: Azimuth angle of major axis of confidence
        ellipsoid. Corresponds to Tait-Bryan angle ψ. Unit: deg
    :param major_axis_rotation: This angle describes a rotation about the
        confidence ellipsoid’s major axis which is required to define the
        direction of the ellipsoid’s minor axis. Corresponds to Tait-Bryan
        angle θ.
        
% Here is the 2D method
    @classmethod
    def from_uncerts(cls, x_err, y_err, c_xy, dist, baz,debug=False):
        """Set error ellipse using common epicenter uncertainties
        
        Call as e=ellipse.from_uncerts(x_err,y_err,c_xy,dist,baz)
        
        Inputs:
            x_err: x error
            y_err: y error
            c_xy:  x-y covariance
            dist:  distance of center from observer
            baz:   back-azimuth from observer (radians)
            
            x_err, y_err and dist units must be the same
        """
        x,y=dist*m.sin(baz*m.pi/180) , dist*m.cos(baz*m.pi/180)
        cov=[[x_err**2, c_xy],[c_xy, y_err**2]]
        evals, evecs = np.linalg.eig(cov)
        if debug:
            print(evecs)
            print(evals)
        # Sort eigenvalues in decreasing order and select the semi-major and semi-minor axis lengths
        sort_indices = np.argsort(evals)[::-1]
        a,b=evals[sort_indices[0]] , evals[sort_indices[1]]
        # Calculate angle of semi-major axis
        x_v1, y_v1 = evecs[:, sort_indices[0]]  # Eigenvector with largest eigenvalue
        theta = np.tanh((x_v1)/(y_v1))  
        return cls(a,b,theta=theta,center=(x,y))

An unsuccessful effort in 3D:
     https://www.mathworks.com/matlabcentral/answers/299648-confidence-ellipsoid-from-eigenvalues
     
Want 
OriginUncertainty.from_xy(xerr,yerr,c_xy)
OriginUncertainty.from_xyz(xerr,yerr,zerr,c_xy,c_yz,c_xz)
OriginUncertainty.from_covariance(C) # C can be 2x2 (xy) or 3x3(xyz)
xerr,yerr,zerr,c_xy,c_xz,c_yz=OriginUncertainty.to_xyz()
xerr,yerr,c_xy=OriginUncertainty.to_xy()
C=OriginUncertainty.to_covariance() # outputs 2x2 or 3x3 depending on what is available
C=OriginUncertainty.to_xycovariance() # outputs 2x2
# Should make/use:
ConfidenceEllipsoid.from_xyz(xerr,yerr,zerr,c_xy,c_yz,c_xz)
ConfidenceEllipsoid.from_covariance(C)
C=Confidence_Ellipsoid.to_covariance()
xerr,yerr,zerr,c_xy,c_xz,c_yz=Confidence_Ellipsoid.to_xyz()
xerr,yerr,c_xy=Confidence_Ellipsoid.to_xy()